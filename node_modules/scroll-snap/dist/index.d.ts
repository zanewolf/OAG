interface ScrollSnapConfiguration {
    /**
     * snap-destination for x and y axes
     * should be a valid css value expressed as px|%|vw|vh
     */
    snapDestinationX?: string | number;
    snapDestinationY?: string | number;
    /**
     * time in ms after which scrolling is considered finished
     */
    timeout?: number;
    /**
     * duration in ms for the smooth snap
     */
    duration?: number;
    /**
     * threshold to reach before scrolling to next/prev element, expressed as a percentage in the range [0, 1]
     */
    threshold?: number;
    /**
     * when true, the scroll container is not allowed to "pass over" the other snap positions
     */
    snapStop?: boolean;
    /**
     * custom easing function
     * @param t normalized time typically in the range [0, 1]
     */
    easing?: (t: number) => number;
}
export default class ScrollSnap {
    snapDestinationX: ScrollSnapConfiguration['snapDestinationX'];
    snapDestinationY: ScrollSnapConfiguration['snapDestinationY'];
    timeout: ScrollSnapConfiguration['timeout'];
    duration: ScrollSnapConfiguration['duration'];
    threshold: ScrollSnapConfiguration['threshold'];
    snapStop: ScrollSnapConfiguration['snapStop'];
    easing: ScrollSnapConfiguration['easing'];
    element: HTMLElement;
    listenerElement: HTMLElement | Window;
    target: HTMLElement;
    animating: boolean;
    private onAnimationEnd;
    private scrollHandlerTimer;
    private scrollSpeedTimer;
    private scrollStart;
    private speedDeltaX;
    private speedDeltaY;
    private snapLengthUnit;
    private lastScrollValue;
    private animationFrame;
    constructor(element: HTMLElement, config: ScrollSnapConfiguration);
    private checkScrollSpeed;
    private saveDeclaration;
    private bindElement;
    private unbindElement;
    private startAnimation;
    /**
     * scroll handler
     * this is the callback for scroll events.
     */
    private handler;
    private animationHandler;
    private getNextSnapPoint;
    private isAboveThreshold;
    private roundByDirection;
    private stayInBounds;
    private parseSnapCoordValue;
    private getYSnapLength;
    private getXSnapLength;
    private isEdge;
    private smoothScroll;
    bind(callback?: () => void): this;
    unbind(): this;
}
export {};
